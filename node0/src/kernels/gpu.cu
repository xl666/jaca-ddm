


extern "C"
__device__ int classify(float* ins, int iniIns, int* attributes, int* isLeaf, int* numbersOfArcs, int* evalTypes, float* vals, int* nodeIndices, int MAX_NUM_ARCS)
{
  int actual = 0;
  while(isLeaf[actual] == 0) //is not a leaf
    {			
      int auxx = actual;
      int att = attributes[actual];			
      float insVal = ins[iniIns +  att]; //the actual value of the attribute for this instance
      //System.out.println("Atributoo: " + att + "vaal :" + insVal);
      for(int i = 0; i < numbersOfArcs[actual]; i++) //traverse each arc
	{
	  int arcIndi = (actual * MAX_NUM_ARCS) + i; //the actual index of the arc
	  float arcVal = vals[arcIndi];				
	  int evType = evalTypes[arcIndi];
	  //System.out.println("aaaarc :" + arcVal + "evvtype" + evType);
	  if(evType == 0)
	    {
	      if(insVal <=  arcVal) //<=
		{			
		  actual = nodeIndices[arcIndi];
		  break;
		}
						
	      else
		{
		  continue;
		}
	    }
	  else if(evType == 1)
	    {
	      if(insVal >  arcVal) // >
		{
		  actual = nodeIndices[arcIndi];
		  break;
		}
	      else
		continue;
	    }
	  else if(evType == 2)
	    {
	      if(insVal ==  arcVal) // =
		{						
		  actual = nodeIndices[arcIndi];
		  break;
		}
	      else
		continue;
	    }									
	}
      if(auxx == actual) //there wasn't an appropiate path, None value found 
	{
	  //System.out.println("Aquí se ciclaría :" + insVal);
	  return 0;
	}
			
    }
  //pack two integers in one using bitwise operations 8388607 possible leaves, 256 possible class values
  int auxPack = isLeaf[actual] << 8; // reserve 1 byte for class value
  return (auxPack | attributes[actual]);  //or bitewise pack
}


extern "C"
__global__ void hilo(float* ins, int insSize, int chunk, int* attributes, int* isLeaf, int* numbersOfArcs, int* evalTypes, float* vals, int* nodeIndices, int MAX_NUM_ARCS, int NIntances, int* res, int* used, int* resHojas)
{
  // Each thread computes one element of C
  // by accumulating results into Cvalue
  int tid = blockIdx.x * blockDim.x + threadIdx.x;
  int i =  tid * chunk; //begin to save index in own slot, i points to the instance index
  int fin = i + chunk;
  int resi = i;
  while(i < NIntances && i < fin)
    {
      int iniIns= i * insSize; 
      int auxPredicted = classify(ins, iniIns, attributes, isLeaf, numbersOfArcs, evalTypes, vals, nodeIndices, MAX_NUM_ARCS); //its necessesary to unpack
      int predicted = auxPredicted & 255; //bitwise unpack
      int actual = ins[iniIns + insSize-1];
      if(predicted != actual) //counter example
	{
	  res[resi] = i; //this index was a counter example
	  resHojas[resi] = auxPredicted >> 8; //unpack leaf index
	  resi++;
        }
      i++;
    }
  //if(tid < NIntances)
    used[tid] =  resi -  (tid * chunk);  //how many results does this thread saved
  
}

//extracts the size needed for the counter examples set, to allocate memory for res
extern "C"
__global__ void  countSize(int* used, int threads, int*  res)
{
  int cont = 0;
  for(int i = 0; i < threads; i++)
    {
      cont += used[i];
    }
  res[0] = cont;
}

/*
Takes the number of results generated by each thread and crates a shrink version
 */
extern "C"
__global__ void  genResult(int* resHuecos, int* resHojas, int* used, int threads, int chunk, int*  res, int* resCounterHojas)
{
  int loc = 0; //the loc in resHuecos
  int resi = 0;
  for(int i = 0; i < threads; i++)
    {
      for(int j = 0; j < used[i]; j++)
	{
	  res[resi] = resHuecos[loc+j];
	  resCounterHojas[resi] = resHojas[loc+j];
	  resi++;
	}
      loc += chunk;
    }
}

//removes counter examples
extern "C"
__global__ void filter(int* counterIndis, float* data, int lenData, int lenIns, float* newData)
{
  int indiCounter = 0;
  int actual = 0;
  int resi = 0;
  for(int i = 0; i < lenData; i++)
    {
      if(i == counterIndis[indiCounter]) //don't copy
	{
	  indiCounter++;
	}
      else //copy the instance
	{
	  for(int j = 0; j < lenIns; j++)
	    {
	      newData[resi+j] = data[actual+j];
	    }
	  resi+=lenIns;
	}
      actual += lenIns;
    }
}

//removes counter examples
extern "C"
__global__ void filterParallel(int* counterIndis, int* used, float* data, int lenData, int lenIns, int chunk, int threads, float* newData)
{
  int tid = blockIdx.x * blockDim.x + threadIdx.x;
  //determine search space
  int iniIndi = 0;
  int iniChunk = tid * chunk;
  if(iniChunk >= lenData) //you can't do anything
    return;
   
  for(int i = 0; i < tid; i++) //how many counter examples do the other thrads found
    {
      iniIndi += used[i];
    }
  // instances before tid minus the counter found multiplied by the len of the instance
    int iniResi = ((tid * chunk) - iniIndi) * lenIns;
  
  // int finIndi = iniIndi+ used[tid];  
  int finChunk = iniChunk + chunk;
  
  int indiCounter = iniIndi;
  int actual = iniChunk * lenIns;
  int resi = iniResi;
  int i = iniChunk;
  while(i < lenData && i < finChunk)
    {
      if(i == counterIndis[indiCounter]) //don't copy
	{
	  indiCounter++;
	}
      else //copy the instance
	{
	  for(int j = 0; j < lenIns; j++)
	    {
	      newData[resi+j] = data[actual+j];
	      //newData[resi+j] = 0.0;
	    }
	  resi+=lenIns;
	}
      actual += lenIns;
      i++;
    }
}

//compute how many counters are per leaf, pos 0 is not used
extern "C"
__global__ void countersForLeaf(int numCounters, int* hojasCounters, int hojas, int*res)
{
  //initialize array
  for(int i = 0; i < hojas; i++)
    {
      res[i] = 0;
    }
  //count counters for each leaf
  for(int i = 0; i < numCounters; i++)
    {
      res[hojasCounters[i]]++;
    }
}

//compute how many counter examples to consider per leaf accoriding to a %
extern "C"
__global__ void countersPerLeaf(int hojas, int* countersInHojas, float percent, int min, int* res, int* count)
{
  count[0] = 0; // to save total number
  for(int i = 0; i < hojas; i++)
    {
      int normal = countersInHojas[i];
      int consider = normal * percent;
      if(consider > min)
	{
	  res[i] = consider;
	  count[0] += consider;
	}
      else
	{
	  res[i] = normal;
	  count[0] += normal;
	}
    }
}

//filters counter examples 
extern "C"
__global__ void filterCounters(int hojas, int numCounters, int* counters, int* hojasCounters, int* countersPerHoja, int* contador, int* res)
{
  //put contador to 0
  for(int i = 0; i < hojas; i++)
    {
      contador[i] = 0;
    }
  //traverse each counter example
  int resi = 0;
  for(int  i = 0; i < numCounters; i++)
    {
      int h = hojasCounters[i];
      if(contador[h] < countersPerHoja[h])
	{
	  res[resi] = counters[i];
	  resi++;
	  contador[h]++;
	}
    }
}

extern "C"
__global__ void calcAcc(float* ins, int insSize, int chunk, int* attributes, int* isLeaf, int* numbersOfArcs, int* evalTypes, float* vals, int* nodeIndices, int MAX_NUM_ARCS, int NIntances, int* res)
{
  // Each thread computes one element of C
  // by accumulating results into Cvalue
  int tid = blockIdx.x * blockDim.x + threadIdx.x;
  int i =  tid * chunk; //begin to save index in own slot, i points to the instance index
  int fin = i + chunk;
  res[tid] = 0; 
  while(i < NIntances && i < fin)
    {
      int iniIns= i * insSize; 
      int auxPredicted = classify(ins, iniIns, attributes, isLeaf, numbersOfArcs, evalTypes, vals, nodeIndices, MAX_NUM_ARCS);
      int predicted = auxPredicted & 255; //bitwise unpack
      int actual = ins[iniIns + insSize-1];
      if(predicted == actual) //correctly classified
	{
	  res[tid] += 1; 
        }
      i++;
    }
  //if(tid < NIntances)
}

//extracts the total sum computed by each thread
extern "C"
__global__ void totalAcc(int* sums, int threads, int* res)
{
  int cont = 0;
  for(int i = 0; i < threads; i++)
    {
      cont += sums[i];
    }
  res[0] = cont;
}
